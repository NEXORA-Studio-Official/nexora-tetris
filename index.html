<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.11.1/lib/p5.min.js"></script>
  <style>
    html, body { margin:0; padding:0; background:#0f0f0f; }
    canvas { display:block; margin:0 auto; }
  </style>
</head>
<body>
<script>

let cols = 10, rows = 20;
let cell = 28;
let panelW = 220;

let board = [];
let piece = null;
let nextPiece = null;

let counter = 0;

let score = 0;
let lines = 0;
let level = 0;

let mode = "play";

let prevLeft = false;
let prevRight = false;
let prevDown = false;

const SHAPES = [
[[1,1,1,1]],
[[1,1],[1,1]],
[[0,1,0],[1,1,1]],
[[1,0,0],[1,1,1]],
[[0,0,1],[1,1,1]],
[[0,1,1],[1,1,0]],
[[1,1,0],[0,1,1]],
];

const COLORS = [
[0,240,240],
[240,240,0],
[180,0,240],
[0,120,240],
[240,140,0],
[0,240,0],
[240,0,0],
];

function setup(){
createCanvas(cols*cell+panelW, rows*cell);
restart();
}

function restart(){
board = Array.from({length:rows},()=>Array(cols).fill(0));
score = 0;
lines = 0;
level = 0;
mode="play";

prevLeft=false; prevRight=false; prevDown=false;

nextPiece = makeRandomPiece();
spawnPiece();
counter=0;
}

function makeRandomPiece(){
let idx=floor(random(SHAPES.length));
return {m:copyMatrix(SHAPES[idx]), c:COLORS[idx]};
}

function spawnPiece(){
piece=nextPiece;
nextPiece=makeRandomPiece();
piece.x=floor(cols/2)-floor(piece.m[0].length/2);
piece.y=0;
if(collides(piece.x,piece.y,piece.m)) mode="gameover";
}

function draw(){
background(15);
drawBoard();
if(piece) drawPiece(piece.x,piece.y,piece.m,piece.c);
drawPanel();

if(mode!=="play"){ drawEnd(); return; }

handleInput();

counter++;
if(counter>=dropSpeed()){
counter=0;
tickDown();
}
}

function drawEnd(){
fill(255);
textAlign(CENTER,CENTER);
textSize(36);
text("GAME OVER",(cols*cell)/2,height/2-10);
textSize(16);
text("Press R to Restart",(cols*cell)/2,height/2+20);
}

function drawPanel(){
let x0=cols*cell;

fill(10); noStroke();
rect(x0,0,panelW,height);

fill(255);
textAlign(CENTER,TOP);
textSize(14);
text("Created by Daniel Cejka\nfrom the NEXORA team",x0+panelW/2,8);

textAlign(LEFT,TOP);
textSize(18);
text("Score: "+score,x0+16,70);
text("Level: "+level,x0+16,98);
text("Lines: "+lines,x0+16,126);

textSize(16);
text("Next:",x0+16,170);

if(nextPiece) drawPreview(x0+16,200,nextPiece.m,nextPiece.c);
}

function drawPreview(px,py,m,c){
let s=22;
for(let y=0;y<m.length;y++){
for(let x=0;x<m[y].length;x++){
if(m[y][x]) drawBlock(px+x*s,py+y*s,s,c);
}
}
}

function drawBoard(){
for(let y=0;y<rows;y++){
for(let x=0;x<cols;x++){
let v=board[y][x];
if(v===0){
noFill(); stroke(35);
rect(x*cell,y*cell,cell,cell);
}else{
drawBlock(x*cell,y*cell,cell,v);
}
}
}
}

function drawPiece(px,py,m,c){
for(let y=0;y<m.length;y++){
for(let x=0;x<m[y].length;x++){
if(m[y][x]) drawBlock((px+x)*cell,(py+y)*cell,cell,c);
}
}
}

function drawBlock(px,py,s,c){
noStroke(); fill(c[0],c[1],c[2]);
rect(px,py,s,s);
stroke(0); strokeWeight(2); noFill();
rect(px,py,s,s);
strokeWeight(1);
}

function keyPressed(){
if(mode!=="play" && (key==="r"||key==="R")){ restart(); return; }
if(mode!=="play") return;
if(key==="w"||key==="W") tryRotate();
}

function handleInput(){
let left=keyIsDown(65);
let right=keyIsDown(68);
let down=keyIsDown(83);

let justLeft=left&&!prevLeft;
let justRight=right&&!prevRight;
let justDown=down&&!prevDown;

if(justLeft) tryMove(-1,0);
if(justRight) tryMove(1,0);
if(justDown) tickDown();

prevLeft=left;
prevRight=right;
prevDown=down;
}

function tickDown(){
if(!tryMove(0,1)){
lockPiece();
let cleared=clearLines();
score += cleared * 10;
level = floor(score / 100);
spawnPiece();
}
}

function tryMove(dx,dy){
let nx=piece.x+dx;
let ny=piece.y+dy;
if(!collides(nx,ny,piece.m)){
piece.x=nx; piece.y=ny;
return true;
}
return false;
}

function tryRotate(){
let rotated=rotateMatrix(piece.m);
if(!collides(piece.x,piece.y,rotated)){
piece.m=rotated;
}
}

function collides(px,py,m){
for(let y=0;y<m.length;y++){
for(let x=0;x<m[y].length;x++){
if(!m[y][x]) continue;
let bx=px+x;
let by=py+y;
if(bx<0||bx>=cols||by<0||by>=rows) return true;
if(board[by][bx]!==0) return true;
}
}
return false;
}

function lockPiece(){
for(let y=0;y<piece.m.length;y++){
for(let x=0;x<piece.m[y].length;x++){
if(piece.m[y][x]) board[piece.y+y][piece.x+x]=piece.c;
}
}
}

function clearLines(){
let cleared=0;
for(let y=rows-1;y>=0;y--){
let full=true;
for(let x=0;x<cols;x++){
if(board[y][x]===0){ full=false; break; }
}
if(full){
board.splice(y,1);
board.unshift(Array(cols).fill(0));
cleared++;
y++;
}
}
lines+=cleared;
return cleared;
}

function dropSpeed(){
return max(10,48-level*4);
}

function rotateMatrix(m){
let h=m.length;
let w=m[0].length;
let res=[];
for(let x=0;x<w;x++){
let row=[];
for(let y=h-1;y>=0;y--) row.push(m[y][x]);
res.push(row);
}
return res;
}

function copyMatrix(m){ return m.map(r=>r.slice()); }

</script>
</body>
</html>
